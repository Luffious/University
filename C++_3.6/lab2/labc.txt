template <typename T>
class Stack
{
    private:
        struct Element
        {
            Element* nextelemet = nullptr;
            Element* backelemen = nullptr;
            T value;
            
        };
        int length = 0; 
        Element* lastelemetofturn = nullptr;
        Element* firstelementofturn = nullptr;
        void creatFirstElement()
        {
            lastelemetofturn = new Element;
            firstelementofturn = lastelemetofturn;
        }
        void creatNextElement()
        {
            firstelementofturn->nextelemet = new Element;
            firstelementofturn->nextelemet->backelemen = firstelementofturn;
            firstelementofturn = firstelementofturn->nextelemet;

        }
    public:
      
        Stack(const int N = 0) : length(N)
        {
            if(length > 0) 
            {
                creatFirstElement();
                creatNextElement();
                
                
                for (int i = 1; i <= length; i++)
                {
                    creatNextElement();

                }
                
            }
        } 

        class ReversStackIterator
        {
            private:
                Element* element;
            public:
                using value_type = T ;
                using reference = T& ;
                using pointer = T* ;
                using difference_type = std::ptrdiff_t ;
                using iterator_category = std::random_access_iterator_tag ;
                
                ReversStackIterator(const ReversStackIterator& it) : element(it.element)
                {}
                
                ReversStackIterator(Element* el)
                {
                    element = el;
                }
                 ReversStackIterator& operator=(const ReversStackIterator& it)
                {
                    element = it.element;
                    return *this;
                }
                
              
                ReversStackIterator operator+(const int num)
                {
                    ReversStackIterator tmp = *this;
                    return tmp+=num;
                }
                ReversStackIterator operator-(const int num)
                {
                    ReversStackIterator tmp = *this;
                    return tmp-=num;
                }
                
                friend ReversStackIterator operator+(const int num, const ReversStackIterator &it )
                {
                     ReversStackIterator tmp = it;
                     return tmp+=num;

                }
                ReversStackIterator& operator+=(const int num)
                {
                    typename StackIterator::difference_type m = num;
                    if (m >= 0) 
                    while(m--) 
                        ++(*this);
                    else 
                    while(m++)
                        --(*this);
                    return *this;

                }
                ReversStackIterator& operator-=(const int num)
                {
                    *this+= -num;
                    return *this;

                }
                
            
                ReversStackIterator  operator++(int)
                {
                    ReversStackIterator old  = *this;
                    ++(*this);
                    return old;
                }
                ReversStackIterator&  operator++()
                {
                    element = element->nextelemet;
                    return *this;
                }
                ReversStackIterator&  operator--()
                {
                    element = element->backelemen;
                    return *this;
                }
                 ReversStackIterator  operator--(int)
                {
                    ReversStackIterator old  = *this;
                    --(*this);
                    return old;
                }
                bool operator<(const ReversStackIterator &it)
                {
                    return (it - *this) > 0;
                }
                
                bool operator==(const ReversStackIterator &it) const
                {
                    return element == it.element;
                }
                bool operator!=(const ReversStackIterator &it) const
                {
                    return element != it.element;
                }
                bool operator>(const ReversStackIterator &it)
                {
                    return it < *this;
                }
            
                bool operator>=(const ReversStackIterator &it)
                {
                    return !(*this < it);
                }
                bool operator<=(const ReversStackIterator &it)
                {
                    return !(*this > it);
                }

                reference operator[](int num) { return *(*this + num); }
                pointer operator->() { return element; }

                reference operator *() { return element->value; }

                difference_type operator-(const ReversStackIterator &it) const
                {
                    int n = 0;
                    Element* lel = element;
                    while (lel != it.element && lel != nullptr)
                    {
                        n++;
                        lel = lel->nextelemet;
                        
                    }
                    return n;
                }
        };

        class StackIterator
        { 
            private:
                Element* element;
            public:
                using value_type = T ;
                using reference = T& ;
                using pointer = T* ;
                using difference_type = std::ptrdiff_t ;
                using iterator_category = std::random_access_iterator_tag ;
            
            
                StackIterator(const StackIterator& it) : element(it.element)
                {}
                
                StackIterator(Element* el)
                {
                    element = el;
                }
                 StackIterator& operator=(StackIterator& it )
                {
                    element = it.element;
                    return *this;
                }
                StackIterator operator+(const int num)
                {
                    StackIterator tmp = *this;
                    return tmp+=num;
                }
                StackIterator operator-(const int num)
                {
                    StackIterator tmp = *this;
                    return tmp-=num;
                }
                
                friend StackIterator operator+(const int num, const StackIterator &it )
                {
                     StackIterator tmp = it;
                     return tmp+=num;

                }
                StackIterator& operator+=(const int num)
                {
                    typename StackIterator::difference_type m = num;
                    if (m >= 0) 
                    while(m--) 
                        ++(*this);
                    else 
                    while(m++)
                        --(*this);
                    return *this;

                }
                StackIterator& operator-=(const int num)
                {
                    *this+= -num;
                    return *this;

                }
                
                StackIterator  operator++(int)
                {
                    StackIterator old  = *this;
                    ++(*this);
                    return old;
                }
                StackIterator&  operator++()
                {
                    element = element->backelemen;
                    return *this;
                }
                StackIterator&  operator--()
                {
                    element = element->nextelemet;
                    return *this;
                }
                 StackIterator  operator--(int)
                {
                    StackIterator old  = *this;
                    --(*this);
                    return old;
                }
                bool operator<(const StackIterator &it)
                {
                    return (it - *this) > 0;
                }
                
                bool operator==(const StackIterator &it) const
                {
                    return element == it.element;
                }
                bool operator!=(const StackIterator &it) const
                {
                    return element != it.element;
                }
                bool operator>(const StackIterator &it)
                {
                    return it < *this;
                }
            
                bool operator>=(const StackIterator &it)
                {
                    return !(*this < it);
                }
                bool operator<=(const StackIterator &it)
                {
                    return !(*this > it);
                }

                reference operator[](int num) { return *(*this + num); }
                pointer operator->() { return element; }

                reference operator *() { return element->value; }

                difference_type operator-(const StackIterator &it) const
                {
                    int n = 0;
                    Element* rel = element;
                    while (rel != it.element && rel != nullptr)
                    {
                        n++;
                        rel = rel->nextelemet;
                        
                    }
                    return n ;
                }



        };
    
        int getLength()
        {
            return length;
        }

        StackIterator begin()
        {
            
            
            if(length > 0)
            {
                
                StackIterator itr(firstelementofturn->backelemen);
                return itr;
            }
            else
            {
                StackIterator itr(nullptr);
                return itr;

            }
            

        }
        StackIterator  end()
        {
            
            if(length > 0)
            {
                
                StackIterator itr(lastelemetofturn);
                return itr;
            }
            else
            {
                StackIterator itr(nullptr);
                return itr;

            }

        }

        ReversStackIterator  rbegin()
        {
            
            
            if(length > 0)
            {
                
                ReversStackIterator itr(lastelemetofturn->nextelemet);
                return itr;
            }
            else
            {
                ReversStackIterator itr(nullptr);
                return itr;

            }
            

        }
        ReversStackIterator  rend()
        {
            
            if(length > 0)
            {
                
                ReversStackIterator itr(firstelementofturn);
                return itr;
            }
            else
            {
                ReversStackIterator itr(nullptr);
                return itr;

            }

        }
        T front()
        {
            if(length > 0)
                return firstelementofturn->backelemen->value;
            else{
                T Null ;
                return Null;}
            
        }
        void pop()
        {
            if (length > 0)
            {
                
                length--;

                firstelementofturn->backelemen = firstelementofturn->backelemen->backelemen;

                delete firstelementofturn->backelemen->nextelemet;
                firstelementofturn->backelemen->nextelemet = firstelementofturn;
                

            }

        }
        void push(T element)
        {
            if(length == 0)
            {
                creatFirstElement();
                creatNextElement();
                firstelementofturn->value = element;
                creatNextElement();
            } 
            else
            {
                
                firstelementofturn->value = element;
                creatNextElement();
            }
            
            length++;
        }

        bool IsEmpty()
        {
            return length > 0 ? true : false; 
        }
        ~Stack()
        {
            
            while(firstelementofturn->backelemen != nullptr)
            {
                firstelementofturn = firstelementofturn->backelemen;
                delete firstelementofturn->nextelemet;
            }
            delete firstelementofturn;

        }

};